/**
 * JavaCC file
 */

options {
  JDK_VERSION = "1.6";
  STATIC = false;
}
PARSER_BEGIN(JCCMinijavaParser)
package parser;

import ast.*;
import java.util.ArrayList;
import java.util.List;
import VarDecl.Kind.*;

public class JCCMinijavaParser {
}

PARSER_END(JCCMinijavaParser)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
|	< MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/" >
|   < SINGLE_LINE_COMMENT: "//" (~["\n"])* >
|   < #NOT_STAR_SLASH: ~["*"] | "*" ~["/"] >
}

TOKEN : /* KEYWORDS */
{
	< PRINT:		"System.out.println" >
|	< RETURN: 		"return" >
| 	< INT:			"int" >
| 	< BOOLEAN: 		"boolean" >
| 	< CLASS: 		"class" >
|   < PUBLIC:       "public" >
| 	< STATIC: 		"static" >
| 	< VOID: 		"void" >
| 	< MAIN: 		"main" >
| 	< STRING: 		"String" >
| 	< EXTENDS: 		"extends" >
| 	< IF: 		    "if" >
| 	< ELSE: 		"else" >
| 	< WHILE: 		"while" >
| 	< NEW: 			"new" >
| 	< LENGTH: 		"length" >
| 	< TRUE: 		"true" >
| 	< FALSE: 		"false" >
| 	< THIS: 		"this" >
}
TOKEN : /* SEPARATORS and OPERATORS*/
{	<LPAREN: "(">
|	<RPAREN: ")">
|	<LBRACKET: "[">
|	<RBRACKET: "]">
|	<LBRACE: "{">
|	<RBRACE: "}">
|	<ASSIGN: "=">
|	<QUESTION:	 "?">
|	<PLUS:	 "+" >
|	<MINUS:  "-" >
|	<MULT:   "*" >
|	<SMALLER:"<">
|	<NOT:	 "!">
| 	<COLON:	 ":" >
| 	<COMMA:	"," >
| 	<SEMICOLON:	 ";" >
| 	<DOT: "." >
| 	<AND: "&&" >
}

TOKEN :
{   < INTEGER_LITERAL: ( <DIGIT> )+ >
|   < IDENTIFIER: <LETTER> (<LETTER> | "_" | <DIGIT>)* >
|   < #LETTER: ["A" - "Z", "a" - "z"] >
|   < #DIGIT: ["0" - "9"] >
}


Program Program() : {
    NodeList<AST> ss = new NodeList<AST>();
    MainClass m;
    ClassDecl c;
}
{
    m = MainClass() ( c = ClassDeclaration() { ss.add(c); } )* <EOF>
	{ return new Program(m, ss); }
}


MainClass MainClass() : {
    String className;
    String argName;
    Statement statement;
}
{
    <CLASS> className = Identifier() "{"
    <PUBLIC> <STATIC> <VOID> <MAIN> "(" <STRING> "[" "]" argName = Identifier() ")"
    "{" statement = Statement() "}" "}"
    { return new MainClass(className, argName, statement); }
}


ClassDecl ClassDeclaration() : {
    String className;
    String superName = null; //May be null!
    NodeList<VarDecl> vars = new NodeList<VarDecl>();
    NodeList<MethodDecl> methods = new NodeList<MethodDecl>();
    VarDecl field;
    MethodDecl method;
}
{
    <CLASS> className = Identifier() ( <EXTENDS> superName = Identifier() )? "{"
    ( field = VarDeclaration(FIELD) { vars.add(field); } )*
    ( method = MethodDeclaration() { methods.add(method); } )* "}"
    { return new ClassDecl(className, superName, vas, methods); }
}

VarDecl VarDeclaration(VarDecl.Kind kind) : {
    Type type;
    String name;
    int index = 0; // what's the use of index for fields and local variables ???
}
{
    type = Type() name = Identifier() ";"
    { return new VarDecl(kind, type, name, index); }
}

MethodDecl MethodDeclaration() : {
    Type returnType;
    String methodName;
    NodeList<VarDecl> formals;
    NodeList<VarDecl> locals;
    NodeList<Statement> statements;
    Expression returnExp;
    VarDecl local;
    Statement s;
}
{
 <PUBLIC> returnType = Type() methodName = Identifier()
 "(" ( type = Type() name = Identifier()
 { formals.add(new VarDecl(type, name, formals.size())); }
 // can I declare local variables not inside declaraction braces above???

 ( "," t = Type() n = Identifier() )* )? ")"
 { formals.add(new VarDecl(t, n, formals.size())); }

 "{" ( local = VarDeclaration(LOCAL) { locals.add(local); } )*
 ( s = Statement() { statements.add(s); } )*
 <RETURN> returnExp = Expression() ";" "}"

 { return new MethodDecl(returnType, methodName, formals, locals, statements, returnExp); }
}

Type Type() : {
	Type t;
}
{
    LOOKAHEAD(2) // due to common prefix
      <INT> "[" "]" { t = new IntArrayType(); }
    | <BOOLEAN>     { t = new BooleanType(); }
    | <INT>         { t = new IntegerType(); }
    | Identifier()  { t = new UnknownType(); }

    { return t; }
}


Statement Statement() : {
	Statement s = null; // this should not be null ever!
	Expression exp;

	NodeList<Statement> statements = new NodeList<Statement>(); // used for block

    Statement thn;
    Statement els;

	Statement body; // used for while

    String name;
    Expression index;
    Expression value;
}
{
	"{" ( s = Statement() { statements.add(s); } )* "}" { s = new Block(statements); }
	| <IF> "(" exp = Expression() ")" thn = Statement() <ELSE> els = Statement() { s = new If(exp, thn, els); }
	| <WHILE> "(" exp = Expression() ")" body = Statement()  { s = new While(exp, body); }
	| <PRINT> "(" exp = Expression() ")" ";" { s = new Print(exp); }
	| LOOKAHEAD(2) name = Identifier() "=" value = Expression() ";" { s = new Assign(name, value); }
	| name = Identifier() "[" index = Expression() "]" "=" value = Expression() ";" { s = new ArrayAssign(name, index, value); }

	{ return s; }
}


Expression Expression() : {
	Expression e, e2, e3;
}
{
        Expression() ( "&&" | "<" | "+" | "-" | "*" ) Expression()
      | Expression() "[" Expression() "]" {  }
      | Expression() "." "length"
      | Expression() "." Identifier() "(" ( Expression() ( "," Expression() )* )? ")"
      | <INTEGER_LITERAL>
      | "true"
      | "false"
      | Identifier()
      | "this"
      | "new" "int" "[" Expression() "]"
      | "new" Identifier() "(" ")"
      | "!" Expression()
      | "(" Expression() ")"

	{ return e; }
}

// For parsing anything with priority same or higher than <
Expression CompExpression() : {
	Expression e, e2;
}
{ 	e=AddExpression()
	( "<" e2=AddExpression()
		{ e = new LessThan(e, e2); }
	)?
	{ return e; }
}
// For parsing anything with priority same or higher than +
Expression AddExpression() : {
	Expression e, e2;
	Token op;
}
{	e=MultExpression()
	( 	(op="+"|op="-")
		e2=MultExpression()
			{ if (op.image.equals("+"))
				e=new Plus(e, e2);
			  else
			  	e=new Minus(e, e2);
			}
	)*
	{ return e; }
}

// For parsing anything with priority same or higher than *
Expression MultExpression() :  {
	Expression e, e2;
}
{	e=NotExpression()
	(	"*" e2=NotExpression()
			{ e = new Times(e, e2); }
	)*
	{ return e; }
}

// For parsing anything with priority same or higher than ! expressions:
Expression NotExpression() : {
	Expression e;
}
{ 	"!" e=NotExpression()
		{ return new Not(e); }
| 	e=PrimaryExpression()
		{ return e; }
}

/* PrimaryExpression is the expression that has highest precedence.*/
Expression PrimaryExpression() : {
	Token t;
	String i, f;
	Expression e;
}
{ t=<INTEGER_LITERAL>					{ return new IntegerLiteral(t.image); }
| i=Identifier()						{ return new IdentifierExp(i); }
| "(" e=Expression() ")"				{ return e; }
}

String Identifier() : {
	Token i;
}
{
	i = <IDENTIFIER>
	{ return i.image; }
}
